/*
 * Projects4Me Copyright (c) 2017. Licensing : http://legal.projects4.me/LICENSE.txt. Do not remove this line
 */

import _ from "lodash";

/**
 * This utility class is used for help the convert the query objects created by
 * the plugin jQuery Query Builder querybuilder.js.org and vice versa
 *
 * @class Parser
 * @namespace Prometheus.Utils
 * @module Query
 * @author Hammad Hassan <gollomer@gmail.com>
 */
export default {

    /**
     * The default query operator mapping
     *
     * @property queryOperators
     * @type Object
     * @for Parser
     * @private
     */
    queryOperators:{
        equal: ":",
        not_equal: "!:",
        in: "CONTAINS",
        not_in: "!CONTAINS",
        less: "<",
        less_or_equal: "<:",
        greater: ">",
        greater_or_equal: ">:",
        between: "BETWEEN",
        not_between: "!BETWEEN",
        begins_with: "STARTS",
        not_begins_with: "!STARTS",
        contains: "CONTAINS",
        not_contains: "!CONTAINS",
        ends_with: "ENDS",
        not_ends_with: "!ENDS",
        is_empty: "EMPTY",
        is_not_empty: "!EMPTY",
        is_null: "NULL",
        is_not_null: "!NULL"
    },

    /**
     * The default rules operator mapping
     *
     * @property rulesOperators
     * @type Object
     * @for Parser
     * @private
     */
    rulesOperators:{
        ":": 'equal',
        "!:": "not_equal",
        "CONTAINS": "contains",
        "!CONTAINS": "not_contains",
        "CONTAINSARRAY": "contains",
        "!CONTAINSARRAY": "not_contains",
        "<": "less",
        "<:": "less_or_equal",
        ">": "greater",
        ">:": "greater_or_equal",
        "BETWEEN": "between",
        "!BETWEEN": "not_between",
        "STARTS": "begins_with",
        "!STARTS": "not_begins_with",
        "ENDS": "ends_with",
        "!ENDS": "not_ends_with",
        "EMPTY": "is_empty",
        "!EMPTY": "is_not_empty",
        "NULL": "is_null",
        "!NULL": "is_not_null"
    },

    /**
     * This function converts a rule object to string
     *
     * @method evalRule
     * @param {Object} rule The rule as generated by Query Builder
     * @return {String} query The query segment corresponding to the rule
     * @private
     */
    evalRule:function(rule){
        if (rule.type == 'date'){
            rule.value = luxon.DateTime.fromFormat(rule.value, 'MM/dd/yyyy').toFormat('yyyy-MM-dd');
        }

        return '('+rule.field+' '+(this.queryOperators[rule.operator])+' '+rule.value+')';
    },

    /**
     * This function is used to convert the rules object generated by getRules
     * function into string query accepted by the Projects4Me API
     *
     * @method getQueryString
     * @param {Object} query The rule object generated by getRules function
     * @return {String} query The string format of the query
     * @public
     */
    getQueryString:function(query){
        let _self = this;
        query.rules.forEach(function(element,index,array){
            if (element.condition === undefined) {
                array[index] = _self.evalRule(element);
            }
            else{
                array[index] = _self.getQueryString(element);
            }
        });
        return ('('+query.rules.join(' '+query.condition+' ')+')');
    },

    /**
     * This function is used to convert the query generated by projects4me into
     * rules object generated compatible with setRules function
     *
     * @method getRules
     * @param {String} query The string format of the query
     * @param {Object} metaData The metadata definition for the rule
     * @return {Object} query The rule object supported by setRules function
     * @public
     */
    getRules:function(query,metaData){
        // count of the statements found
        let count = 1;

        // All the statements found
        let statements = {};

        // The regular expression needed to find all the statements
        let regex = /\([^(]*[^)]\)/g;
        // temporary variable to store the match
        let matches;

        let tillMatch = true;

        while (tillMatch) {
            // get the match
            matches = regex.exec(query);

            // if no match found then break the loop
            if (matches === undefined || matches === null)
            {
                tillMatch = false;
                break;
            }

            // Add the found statements to the object
            statements['$$'+count] = matches[0];

            // Replace with variable
            query = query.substring(0,(matches.index))+'$$'+(count++)+query.substring((regex.lastIndex),query.length);

            // reset the index to match all possible values
            regex.lastIndex = 0;
        }

        // Initiate temporary variables
        let cur_statement;
        let index = 0;


        // Loop all the statements to resolves strings to objects
        for (let statement in statements) {
            // store the current statements
            cur_statement = statements[statement];

            // remove the enclosing parenthesis
            cur_statement = cur_statement.replace(/\(|\)/g,'');

            let result = cur_statement.match(/\$\$/g);
            // if no sub-statement is found then simply resolve the statement
            if (result === null)
            {
                // Break the string down into multiple parts
                index = 0;
                let field = cur_statement.substring(index,cur_statement.indexOf(' ',index));
                index += field.length+1;
                let operator = cur_statement.substring(index,cur_statement.indexOf(' ',index));
                index += operator.length+1;
                let value = cur_statement.substring(index,cur_statement.length);

                // process the operators based on value
                if (operator === 'CONTAINS' || operator === "!CONTAINS")
                {
                    if (value.match(/','/))
                    {
                        operator = this.rulesOperators[operator+'ARRAY'];
                    }
                    else {
                        operator = this.rulesOperators[operator];
                    }
                }
                else {
                    operator = this.rulesOperators[operator];
                }

                /* jshint loopfunc: true */
                let metaDataIndex = _.findIndex(metaData, function(o) { return o.id === field; });
                /* jshint loopfunc: false */

                /* If these statements grow then they must isolated in objects and functions */
                if (metaData[metaDataIndex]['type'] == 'date') {
                    value = luxon.DateTime.fromFormat(value, 'yyyy-MM-dd').toFormat('MM/dd/yyyy');
                }

                // create the statement objects
                statements[statement] ={
                    id: field,
                    field: field,
                    operator: operator,
                    value: value
                };


                if (metaData[metaDataIndex].input !== undefined){
                    statements[statement].input = metaData[metaDataIndex].input;
                }

                if (metaData[metaDataIndex].type !== undefined){
                    statements[statement].type = metaData[metaDataIndex].type;
                }
            }
            // If sub-statement is found
            else {
                // prepare the statement
                statements[statement] = {
                    condition:null,
                    rules:[]
                };

                // find the parts to be replaced
                let toReplace = cur_statement.match(/\$\$[0-9]+/g);

                // If a group statement is found then resolve it by replacing individual parts
                if (cur_statement.match(/ AND | OR /g)) {
                    // Get the current operator
                    let condition = cur_statement.match(/ AND | OR /);
                    condition = condition[0].trim();

                    // populate the statement
                    statements[statement].condition = condition;
                    /* jshint loopfunc: true */
                    toReplace.forEach(function(element){
                        statements[statement].rules.push(statements[element]);
                    });
                    /* jshint loopfunc: false */
                }
                else {
                    // populate the statement
                    statements[statement].condition = 'AND';
                    statements[statement].rules.push(statements[toReplace[0]]);
                }
            }
        }
        query = statements[Object.keys(statements)[Object.keys(statements).length - 1]];
        return query;
    }

};