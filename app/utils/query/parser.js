import _ from "lodash";

/**
  This utility class is used for help the convert the query objects created by
  the plugin jQuery Query Builder querybuilder.js.org and vice versa

  @class parser
  @module App.utils
  @namespace Prometheus
*/
export default {
  /**
    The default query operator mapping

    @param queryOperators
    @type Object
    @for App.utils
    @private
  */
  queryOperators:{
    equal: ":",
    not_equal: "!:",
    in: "CONTAINS",
    not_in: "!CONTAINS",
    less: "<",
    less_or_equal: "<:",
    greater: ">",
    greater_or_equal: ">:",
    between: "BETWEEN",
    not_between: "!BETWEEN",
    begins_with: "STARTS",
    not_begins_with: "!STARTS",
    contains: "CONTAINS",
    not_contains: "!CONTAINS",
    ends_with: "ENDS",
    not_ends_with: "!ENDS",
    is_empty: "EMPTY",
    is_not_empty: "!EMPTY",
    is_null: "NULL",
    is_not_null: "!NULL"
  },

  /**
    The default rules operator mapping

    @param rulesOperators
    @type Object
    @for App.utils
    @private
  */
  rulesOperators:{
    ":": 'equal',
    "!:": "not_equal",
    "CONTAINS": "contains",
    "!CONTAINS": "not_contains",
    "CONTAINSARRAY": "contains",
    "!CONTAINSARRAY": "not_contains",
    "<": "less",
    "<:": "less_or_equal",
    ">": "greater",
    ">:": "greater_or_equal",
    "BETWEEN": "between",
    "!BETWEEN": "not_between",
    "STARTS": "begins_with",
    "!STARTS": "not_begins_with",
    "ENDS": "ends_with",
    "!ENDS": "not_ends_with",
    "EMPTY": "is_empty",
    "!EMPTY": "is_not_empty",
    "NULL": "is_null",
    "!NULL": "is_not_null"
  },

  /**
    This function converts a rule object to string

    @method evalRule
    @param rule {Object} The rule as generated by Query Builder
    @for App.utils
    @return query {String} The query segment conrresponding to the rule
    @private
  */
  evalRule:function(rule){
    return '('+rule.field+' '+(this.queryOperators[rule.operator])+' '+rule.value+')';
  },

  /**
    This function is used to convert the rules object generated by getRules
    function into string query accepted by the porjects4me API

    @method getQueryString
    @param query {Object} The rule object generated by getRules function
    @return query {String} The string format of the query
    @for App.utils
    @public
  */
  getQueryString:function(query){
    var _this = this;
    query.rules.forEach(function(element,index,array){
      if (element.condition === undefined) {
        array[index] = _this.evalRule(element);
      }
      else{
        array[index] = _this.getQueryString(element);
      }
    });
    return ('('+query.rules.join(' '+query.condition+' ')+')');
  },

  /**
    This function is used to convert the query generated by projects4me into
    rules object generated compatible with setRules function

    @method getRules
    @param query {String} The string format of the query
    @return query {Object} The rule object supported by setRules function
    @for App.utils
    @public
  */
  getRules:function(query,metaData){
  	// count of the statements found
  	var count = 1;

  	// All the statements found
  	var statements = {};

  	// The regular expression needed to find all the statements
  	var regex = /\([^(]*[^)]\)/g;
  	// temporary variable to store the match
  	var matches;

  	while (true) {
  		// get the match
  		matches = regex.exec(query);

  		// if no match foung then break the loop
  		if (matches === undefined || matches === null)
  		{
  			break;
  		}

  		// Add the found statements to the object
  		statements['$$'+count] = matches[0];

  		// Replace with variable
  		query = query.substring(0,(matches.index))+'$$'+(count++)+query.substring((regex.lastIndex),query.length);

  		// reset the index to match all possible values
  		regex.lastIndex = 0;
  	}

  	// Initiate temporary variables
  	var cur_statement='';
  	var index = 0;


  	// Loop all the statements to resolves strings to objects
  	for (var statement in statements) {
  		// store the current statements
  		cur_statement = statements[statement];

  		// remove the enclosing parenthesis
  		cur_statement = cur_statement.replace(/\(|\)/g,'');

  		var result = cur_statement.match(/\$\$/g);
  		// if no substatement is found then simply resolve the statement
  		if (result === null)
  		{
  			// Break the string down into multiple parts
  			index = 0;
  			var field = cur_statement.substring(index,cur_statement.indexOf(' ',index));
  			index += field.length+1;
  			var operator = cur_statement.substring(index,cur_statement.indexOf(' ',index));
  			index += operator.length+1;
  			var value = cur_statement.substring(index,cur_statement.length);

  			// processs the operators based on value
        if (operator === 'CONTAINS' || operator === "!CONTAINS")
        {
          if (value.match(/','/))
          {
              operator = this.rulesOperators[operator+'ARRAY'];
          }
          else {
            operator = this.rulesOperators[operator];
          }
        }
        else {
          operator = this.rulesOperators[operator];
        }

        /* jshint loopfunc: true */
        var metaDataIndex = _.findIndex(metaData, function(o) { return o.id === field; });
        /* jshint loopfunc: false */

        // create the statement objects
        statements[statement] ={
            id: field,
            field: field,
            operator: operator,
            value: value
        };

        if (metaData[metaDataIndex].input !== undefined){
          statements[statement].input = metaData[metaDataIndex].input;
        }

        if (metaData[metaDataIndex].type !== undefined){
          statements[statement].type = metaData[metaDataIndex].type;
        }
  		}
  		// If substatement is found
  		else {
  			// prepare the statement
  			statements[statement] = {
  				condition:null,
  				rules:[]
  			};

  			// find the parts to be replaced
  			var toReplace = cur_statement.match(/\$\$[0-9]+/g);

  			// If a group statement is found then resolve it by replacing individual parts
  			if (cur_statement.match(/ AND | OR /g)) {
  				// Get the current operator
  				var conditon = cur_statement.match(/ AND | OR /);
  				conditon = conditon[0].trim();

  				// populate the statement
  				statements[statement].condition = conditon;
                /* jshint loopfunc: true */
  				toReplace.forEach(function(element){
  					statements[statement].rules.push(statements[element]);
  				});
                /* jshint loopfunc: false */
  			}
  			else {
  				// populate the statement
  				statements[statement].condition = 'AND';
  				statements[statement].rules.push(statements[toReplace[0]]);
  			}
  		}
  	}
  	query = statements[Object.keys(statements)[Object.keys(statements).length - 1]];
  	return query;
  }
};
